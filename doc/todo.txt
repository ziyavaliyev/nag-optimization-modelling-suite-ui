To-do: 

----05.10----(w/ Lotz)
Max: 
	- write down reference where he got his examples from
	- User guide, do it prettier


Khang:
	- Discussion of Source code: 
		Say we did "clean" code
		Focus important stuff already
		Math hard but we made it ez
		Gitlab issue, collab
		Testing, examples
		cover more aspects
		splitting up work
	- clean up build strucutre
	- Diagram:
		c++ layer (complex) can be removed later, use dotted arrow in diagram


Yifei:
	- Tech bg: add nonlinear remove others
	- Class Candidate: ...derivative of a function... 	"prone to errors"
	- source code: tree structure
				in doc->user guide.pdf
				wait for hierarchy
	- Test: granularities
				derivatives
				more complex
	- Demo: combine the cmd with words
				add in present the automatic switch by changing con_fun from non linear to linear
	- Summary: space()
				three examples..
				which was.. experience in software..


Korkin:
	- derivative into struct
	- print parameter into monitor.hpp or helper.hpp
	- solver.hpp friends into private member function
	- put manual solvers back in pl0x
	- at the start of every file add:
// info@stce.rwth-aachen.de
// Gruppe 6: Tran, Man Khang; Feldman, Maksim; Valiyev, Ziya; Korkin, Konstantin; Huang, Yifei 
// Betreuer: Lotz, Johannes
	- Code documetantition: derivative.hpp needs some comment, tangential adjoint


*blog post


----23.09----(w/ Lotz)
! One build system : CMAKE same source (check branch CodeTest_yifei)

0. linearity st to mt when contrstaint is linear
1. stats, monitor (to be put in class solver)
2. test(test memory leak too and invalid memory accesses)
3. documentation, doxygen , user/developer
*4. blogpost
5?. Latex slides...

~~QNA~~
1. N = 20 at checking hessian diag weird
 > good enough haha
   or random points (if motivated)
   (structural mode thingie  with dco maybe)

2. lincheck, what exactly, just a bunch of if?
>  Check if contrainst r 100% linear or not. If yes, solve with mt instead of st.
   Bonus: Detect linear and non linear terms of contrainst and reformulate problem. Check with Prof if too hard
   
3. sparse eigenmatrix thingie
   (or maybe not)

4. documentation to template given by uwe or seperate
   done in 2 weeks of 1 to 13 october.
  
   ->dev docu: code comment/ doxygen / report
   ->user docu: how to build make run test 


----09.09----(w/ Lotz)
(0. templated lambda)
1. e04mt, e04st
2. linearity checker (diagonal are 0) 
	->have hessian() function only for diagonal(for speeeeeed)
(*)2.5 sparse matrix automatic, structure/interface, look on google/eigen (the lib) sparse matrix
	->https://eigen.tuxfamily.org/dox/group__TutorialSparse.html
3. Printing out Rinfo and stat somehow. Maybe with additional class.
4. Makefile with cmake
5. testing with googletest and (documentation)
	->start with unit-tests and lastly integration-test
		~/build: ./sample
				cmake .
				ctest -V
6. jacobian (later)

----25.08----
1. Split Model into Solver and Problem.
Pass Problem's members as !reference! in Solver.solve(Problem) call. Reference so as to avoid saving stuff twice

2. Replace std::function with lambda. See lotz_0! 
lambda allows u to pass pre instantiated template stuff, function only pass concrete typed stuff

3. Integrate dco. See lotz_1
Maybe use dco hessian package Lotz mentioned

4. Google Test
make some test for interface which we have already have

5. Low prio: Printing out Rinfo and stat somehow. Maybe with additional class.
	     Sparse Matrix


----28.07----(w/ Lotz)
~~cpp interface~~
1. make stuff private
2. overload << as get method ---------------------------------------------- done
3. smart pointer for handle constructing without giving nvar first
4. Change type double to T (get example from Lotz)
	right now just focus on std::vector<T>
	outside user example just write std::vector<double>
	model, setfunction must be templated
5. Split problem definition into its own class (and rename model class into solver)
6. low prio (sparse matrix)
7. dco (return derivative function as function, example from lotz)
8. run valgrind for memory


~~dco~~
get example from Lotz and ...

~~QNA~~
1. Data Typings
(stick to std::vector<double>>)

2. Function in function
(lambda/ lotzs example)

3. irowa icola
have a look at eigen value for sparsity matrix
instead of saving the a coefficient as 0
(low prio)

4. destructor class
(not needed yet, even with smart pointer for handle cuz it cleans itself)

5. e04sr autogen sr file pls / how do direct c
Lotz will save us ^^.

6. Do you HAVE to set the number of variable when initialising the handle?
Makepointer point at sth (lieber smart pointer), then construct handle when nvar is given later 


----21.07----
1. (Khang, Konstantin, Yifei):
	-- class diagram & wrapper prototype...
	-- memory sanitizer(gcc/clang)
	-- ctest/googletest
2. (Ziya&Max) get dco to run properly; write an example of linearity-check (check 2nd derivative)



----14.07----(w/ Lotz)
1. (Khang, Konstantin, Yifei)nag interface:
--write prettier examples, write code to fit in to old ugly examples
--send non-working pretty example by monday, we will try to fit later until thursday

2. (Ziya&Max)dco: figure it out until thursday

3. (Everyone)be more proactive, help run meeting, respond in chat, whatever, or else Khang is gonna feel like hes talking to a wall and hes gonna cry. (pien)

~~QNA~~
Regarding interface design:
1. method chaining: handle.setOpt(opt).setobjfun(fun).setBla(bla)
> yes, but pass function on solve call tho cuz generic lambda

2. instead of c programming with only struct: can we have c++ class with method?
   like handle.solver(param) instead of solver(handle, param)
   this makes it easier but takes a lot of work to implement. thought?
   see gurobi pdf von ziya page 49

  > write a wrapper on top of examples i have already
  generic lambda (google up later)

3. data type?
f77_integer is actually just a just *long* used as integer. should it just be renamed? in nagcpp_engine_types.hpp
>interface can use whatever data type, however has to check with routine if data size of type is the same else throw error
(static assert)
if it doesnt work user can go handle it themself

4. 2 handler classes, can they be merged?
> bye

5. "remove void, thats C" no C++ uses void too for function without output? Could u elaborate
> int main(void) he meant

6. is there a list of class in the auto c++ or are we to read everything file
>  dont need to

7. how does auto generating code actually work? recommended in this project? 
   to which extend can we copy the auto gen'ed code?
> later

Questions:

1. #ifdef __cplusplus: where is this defined?
> dont need to care

3. in the example we wrote, the objective function is just a normal c++ function.
the lib has specific routines for defining the objective function however, for example e04rg. why?

> do away with the function defining routine, as dco/c++ handles sparsity matrix stuff already and user can just write normal c++ func isntead of weird routine.
 
4. sparsity structure? 
read some math

5. dco how check if linear?
> check 2nd derivative if zero then its linear, z = f(x,y) check d_xx_z and d_yy_z if equal to 0


----30.06----
1. Finish the latex presentation for next week —— Yifei
2. Read through the documentation on nag website and understand how it works ——— everyone
3. Get the NAG library(ver.28.5), dco/c++ and cpp interface; test examples and play around ——— everyone
